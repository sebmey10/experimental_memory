import pika
import os
import time
import psycopg2
import logging
import sys
from trap_processor import clean_trap
BATCH_SIZE = 200
BATCH_TIMEOUT = 0.2
PREFETCH_COUNT = 400


# Note: In the .yaml portion we will need to define all of the env variables.

class Rabbit_Portion:

    def __init__(self):        
        try:
            self.rabbit_host = os.getenv("hostname")
            self.rabbit_port = os.getenv(int("port", "5672"))
            self.rabbit_user = os.getenv("username")
            self.rabbit_pass = os.getenv("password")
            self.queue_name = os.getenv("queue_name", "trap_queue")

        except Exception as e:
            logging.exception("Failed to load credentials") 
            raise

        self.current_batch = [] #holds all traps in batch
        self.delivery_receipts = []
        self.last_delivery = time.time()

        self.connection = None
        self.channel = None



    def open_connection(self):
        creds = pika.PlainCredentials(self.rabbit_user, self.rabbit_pass)
        params = pika.ConnectionParameters(host=self.rabbit_host, port=self.rabbit_port, credentials=creds, blocked_connection_timeout=300)
        connection = pika.BlockingConnection(params)
        channel = connection.channel()
        channel.basic_qos(prefetch_count=PREFETCH_COUNT)
        channel.queue_declare(self.queue_name, durable=True)

        return connection, channel
    


    
    def on_message_recieve(self, ch, method, properties, body):
        # Process the trap message
        processed_trap = clean_trap.process_trap_message(body)
        
        if processed_trap:
            print(f"Received and processed trap: {processed_trap}")
            # Acknowledge the message
            ch.basic_ack(delivery_tag=method.delivery_tag)
            self.current_batch.append(processed_trap)
        else:
            print(f"Failed to process trap message: {body}")
            # Negative acknowledgment - don't requeue
            ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)

        if len(self.current_batch) >= BATCH_SIZE:
            self.send_batch()

        elapsed = time.time() - self.last_delivery

        if elapsed >= BATCH_TIMEOUT:
            self.send_batch()



    def send_batch(self):
        if not self.current_batch:
            return
        
        try:
            success = True
            if success:
                for receipt in self.delivery_receipts:
                    self.channel.basic_nack(delivery_receipts = receipt)

            else:
                for receipt in self.delivery_receipts:
                    self.channel.basic_nack(delivery_receipt=receipt, requeue=True)

        except Exception as e:
            logging.exception("Failed to process trap")

            try:
                for receipt in self.delivery_receipts:
                    self.channel.basic_nack(delivery_receipt=receipt, requeue=True)
            except:
                pass
        finally:
            self.current_batch = []
            self.delivery_receipts = []
            self.last_delivery = time.time()

    def consume_rabbit_messages(self):

        try:
            self.connection, self.channel = self.open_connection()
        except Exception as e:
            logging.exception("failed to connect to RabbitMQ")
            return
        try:
            self.channel.basic_consume(queue=self.queue_name, on_message_callback=self.on_message_recieve, auto_ack=False)
            self.channel.start_consuming()
        except KeyboardInterrupt:
            self.send_batch()

            try:
                self.channel.stop_consuming()
            except:
                pass

            if self.connection and self.connection.is_open:
                self.connection.close()
                sys.exit(0)

        except pika.exceptions.AMQPConnectionError as e:
            print(f"Error connecting to RabbitMQ {e}")
            connected = False
            x=0
            print("Retrying in 5 seconds...")
            while not connected and x <720:
                time.sleep(5)

                try:
                    self.connection, self.channel = self.open_connection()
                    connected = True
                    self.channel.basic_consume(queue=self.queue_name, on_message_callback=self.on_message_recieve, auto_ack=False)

                except pika.exceptions.AMQPConnectionError as e:
                    retry_count += 1

            if not connected:
                sys.exit(1)

        except Exception as e:

            try:
                self.flush_batch()
            except:
                pass
            if self.connection and self.connection.is_open:
                self.connection.close()
            sys.exit(1)

def main():
    consumer = Rabbit_Portion()
    consumer.start_consuming()

if __name__ == "__main__":
    main()
            













