import pika
import os
import time
import psycopg2
import logging
from trap_processor 

BATCH_SIZE = 200
BATCH_TIMEOUT = 0.2
PREFETCH_COUNT = 400


# Note: In the .yaml portion we will need to define all of the env variables.

class Rabbit_Portion():

    trap_data = '''15:54:12 2026/01/17 PDU INFO:
    version                        1
    notificationtype               INFORM
    community                      public
    receivedfrom                   UDP: [10.242.102.12]:161->[10.241.6.48]:162
    errorindex                     0
    requestid                      197295
    transactionid                  6353668
    errorstatus                    0
    messageid                      0
    VARBINDS:
    DISMAN-EVENT-MIB::sysUpTimeInstance type=67 value=Timeticks: (657652704) 76 days, 2:48:47.04
    SNMPv2-MIB::snmpTrapOID.0      type=6  value=OID: ADTRAN-GENGPON-MIB::adGenGponOntSetLOSAlarm
    ADTRAN-GENTRAPINFORM-MIB::adTrapInformSeqNum.0 type=2  value=INTEGER: 197295
    SNMPv2-MIB::sysName.0          type=4  value=STRING: "FB-SK-OLT-03"
    IF-MIB::ifDescr.1647320064     type=4  value=STRING: "Shelf: 1, Slot: 2, Pon: 12, ONT: 7, ONT Serial No: ADTN2424dc6c, ONT Reg ID: "
    IF-MIB::ifIndex.1647320064     type=2  value=INTEGER: 1647320064
    ADTRAN-GENGPON-MIB::adGenGponOntAlarmSlotLosLevel.2 type=2  value=INTEGER: 5
    ADTRAN-GENGPON-MIB::adGenGponOntProvEntry.35.1647320064 type=2  value=INTEGER: 2
    '''
            
    try:
        pika_creds = [
            os.getenv("HOST"),
            int(os.getenv("PORT","5672")), #RabbitMQ's default port sits here   
            pika.PlainCredentials(
                os.getenv("USER_CREDS"),
                os.getenv("PASS")
            ),
        ]

    except Exception as e:
        logging.exception("Failed to load credentials") 
        raise


    def open_connection(pika_creds):
        if not pika_creds:
            raise ValueError("Credentials errored out")
        params_for_channel = pika.ConnectionParameters(*pika_creds,heartbeat=60,)
        conn = pika.BlockingConnection(params_for_channel) # initial connection opened
        return conn

    # The below is where our batch logic should sit. Note: We need to discuss with Casey how much we want to send at once
    def batching(conn):
        pass


    def on_message_recieve(ch,method, properties,body):
        cleaned_trap = process_trap_message(body)


        

    def main():
        connection = None
        try:

            # establish connection
            connection = open_connection(pika_creds)
            channel = connection.channel()

            # set the queue this consumer will listen to
            queue_name = 'put_queue_name_here'

            channel.queue_declare(queue=queue_name, durable=True)

            print(' ---  Queue connection secured, waiting for messages, to exit press CTRL-C  ---  ')

            channel.basic_consume(
                queue = queue_name,
                on_message_callback=on_message_recieve,
                auto_ack=False
            )


        except pika.exceptions.AMQPConnectionError as e:
            print(f"Error connecting to RabbitMQ {e}")
            connected = False
            x=0
            print("Retrying in 5 seconds...")
            while not connected and x <720:
                time.sleep(5)
                try:
                    connection = open_connection(pika_creds)
                    channel = connection.channel()
                    queue_name = ''

                    channel.queue_declare(queue=queue_name, durable=True)

                    print('  ---  Queue connection restored, awaiting messages  ---  ')
                    connected = True
                    channel.basic_consume(
                        queue=queue_name,
                        on_message_callback=on_message_recieve,
                        auto_ack=False
                    )
                except pika.exceptions.AMQPConnectionError as e:
                    print(f"Error on retry of connection: {e}")
                    x+=1
        except KeyboardInterrupt:
            print('Interrupted')
            if connection and connection.is_open:
                connection.close()
            sys.exit(0)


                






    if __name__ == "__main__":
        main()















