from datetime import datetime, timedelta
from src.core.models.ont import Onts
from src.core.models.taps import Taps
from src.core.models.outage import Outage
from src.core.models.locks import Locks
from src.core.models.base import Base
from sqlalchemy import create_engine, and_
from sqlalchemy.orm import sessionmaker


class MinimumWorkflow:
    def __init__(self, database_url='sqlite:///outage_management.db'):
        self.engine = create_engine(database_url)
        Base.metadata.create_all(self.engine)
        self.Session = sessionmaker(bind=self.engine)
        self.session = self.Session()
    
    def process_trap(self, serial_number):
        ont = self.session.query(Onts).filter_by(serial=serial_number).first()
        if not ont:
            print(f"ONT with serial {serial_number} not found")
            return
        
        print(f"Found ONT: {ont}")
        
        # Mark ONT as out (assuming we can use active=False for 'out')
        ont.active = False
        self.session.commit()
        
        # Check for Level 0 outage
        if ont.tap_id:
            self.check_level_0(ont.tap_id)
    
    def check_level_0(self, tap_id):
        """
        Level 0: Check if multiple ONTs under a tap are out within 30 seconds
        """
        print(f"\n--- Checking Level 0 Outage for Tap {tap_id} ---")
        
        # Query ONTs under this tap that are out (active=False)
        onts_out = self.session.query(Onts).filter(
            Onts.tap_id == tap_id,
            Onts.active == False
        ).all()
        
        if len(onts_out) < 2:
            print(f"Only {len(onts_out)} ONT(s) out under tap {tap_id} - no Level 0 outage")
            return
        
        # Check if they occurred within 30 seconds
        timestamps = [ont.updated_at for ont in onts_out if ont.updated_at]
        if len(timestamps) < 2:
            print("Not enough timestamps to check time window")
            return
            
        time_diff = max(timestamps) - min(timestamps)
        
        if time_diff <= timedelta(seconds=30):
            print(f"Level 0 outage detected! {len(onts_out)} ONTs out within {time_diff.total_seconds()} seconds")
            self.create_outage(level=0, tap_id=tap_id)
        else:
            print(f"ONTs out but not within 30 seconds (diff: {time_diff.total_seconds()}s)")
    
    def check_level_1(self):
        """
        Level 1: Check if multiple taps under a parent tap are locked within 30 seconds
        """
        print(f"\n--- Checking Level 1 Outages ---")
        
        # Find all parent taps that have children with locks
        parent_taps = self.session.query(Taps).filter(
            Taps.parent_tap_id.isnot(None),
            Taps.child_taps.any(lock_id.isnot(None))
        ).all()
        
        for parent_tap in parent_taps:
            # Get all child taps with locks
            child_taps = self.session.query(Taps).filter(
                Taps.parent_tap_id == parent_tap.tap_id,
                Taps.lock_id.isnot(None)
            ).all()
            
            if len(child_taps) < 2:
                continue
            
            # Check if they were locked within 30 seconds
            timestamps = [tap.updated_at for tap in child_taps if tap.updated_at]
            if len(timestamps) < 2:
                continue
                
            time_diff = max(timestamps) - min(timestamps)
            
            if time_diff <= timedelta(seconds=30):
                print(f"Level 1 outage detected! {len(child_taps)} taps under parent {parent_tap.tap_id} locked within {time_diff.total_seconds()} seconds")
                self.create_outage(level=1, tap_id=parent_tap.tap_id)
    
    def check_level_2(self):
        """
        Level 2: Check if multiple taps under a strand are locked within 30 seconds
        Note: Current model doesn't have strand-tap relationship, so this is simplified
        """
        print(f"\n--- Checking Level 2 Outages ---")
        
        # Find all taps with locks (simplified - no strand relationship in model)
        taps_with_locks = self.session.query(Taps).filter(
            Taps.lock_id.isnot(None)
        ).all()
        
        # Group by some criteria (simplified - would normally be by strand)
        # This is a placeholder - actual implementation would need strand relationship
        print(f"Found {len(taps_with_locks)} taps with locks (strand grouping not implemented)")
    
    def create_outage(self, level, tap_id):
        """
        Create an outage record and lock the tap
        """
        # Create lock
        lock = Locks(tap_id=tap_id)
        self.session.add(lock)
        self.session.commit()
        
        # Create outage with the lock
        outage = Outage(
            lock_id=lock.lock_id,
            level=level
        )
        self.session.add(outage)
        self.session.commit()
        
        print(f"Created outage at level {level} for tap {tap_id}")
        print(f"Locked tap {tap_id} with lock_id {lock.lock_id}")
        
        # Cascade lock to child taps
        self.cascade_lock(tap_id, lock.lock_id)
    
    def cascade_lock(self, tap_id, lock_id):
        """
        Cascade lock to all child taps and their ONTs
        """
        # Lock all child taps
        child_taps = self.session.query(Taps).filter_by(parent_tap_id=tap_id).all()
        for tap in child_taps:
            tap.lock_id = lock_id
            tap.updated_at = datetime.utcnow()
            print(f"  Cascaded lock to child tap: {tap.tap_id}")
        
        # Lock all ONTs under child taps
        ont_ids = [tap.tap_id for tap in child_taps]
        onts = self.session.query(Onts).filter(Onts.tap_id.in_(ont_ids)).all()
        for ont in onts:
            ont.active = False  # Mark as out
            print(f"  Cascaded lock to ONT: {ont.serial}")
        
        self.session.commit()
    
    def run_workflow(self):
        """
        Run the complete workflow
        """
        print("Starting Minimum Outage Workflow...")
        
        # Create test data
        self.create_test_data()
        
        # Process traps
        self.process_trap("ONT001")
        self.process_trap("ONT002")
        
        # Check higher levels
        self.check_level_1()
        self.check_level_2()
        
        print("\nWorkflow completed!")
    
    def create_test_data(self):
        """
        Create simple test data
        """
        print("Creating test data...")
        
        # Clear existing data
        self.session.query(Locks).delete()
        self.session.query(Outage).delete()
        self.session.query(Onts).delete()
        self.session.query(Taps).delete()
        self.session.commit()
        
        # Create taps
        tap1 = Taps(tap_id=1, parent_tap_id=None)  # Parent tap
        tap2 = Taps(tap_id=2, parent_tap_id=1)     # Child of tap1
        tap3 = Taps(tap_id=3, parent_tap_id=1)     # Child of tap1
        tap4 = Taps(tap_id=4, parent_tap_id=None)  # Independent tap
        
        self.session.add_all([tap1, tap2, tap3, tap4])
        
        # Create ONTs
        ont1 = Onts(serial="ONT001", tap_id=2)
        ont2 = Onts(serial="ONT002", tap_id=3)
        ont3 = Onts(serial="ONT003", tap_id=4)
        
        self.session.add_all([ont1, ont2, ont3])
        self.session.commit()
        
        print("Test data created successfully!")


if __name__ == "__main__":
    workflow = MinimumWorkflow()
    workflow.run_workflow()
